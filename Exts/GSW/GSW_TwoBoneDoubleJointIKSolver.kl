require Math;
require InlineDrawing;
require Kraken;

object TwoBoneDoubleMidJointIKSolver : KrakenSolver {
  Xfo initPose[];

  private Xfo midJoint0TransformXfo;
  private Xfo midJoint2TransformXfo;
};

/// Default Constructor
/// \dfgPresetTitle TwoBoneDoubleMidJointIKSolver_Constructor
/// \dfgPresetColor Color(49, 60, 61)
/// \dfgPresetHeaderColor Color(42, 94, 102)
/// \dfgPresetTextColor Color(168, 229, 240)
/// \dfgPresetFolder Solvers\TwoBoneDoubleMidJointIKSolver
function TwoBoneDoubleMidJointIKSolver()
{
  this.defaultValues["rightSide"] = false;
  this.defaultValues["ikblend"] = 0.0;
  this.defaultValues["root"] = Mat44();
  this.defaultValues["bone0FK"] = Mat44();
  this.defaultValues["bone1FK"] = Mat44();
  this.defaultValues["ikHandle"] = Mat44();
  this.defaultValues["upV"] = Mat44();
  this.defaultValues["bone0Len"] = 654.321;
  this.defaultValues["bone1Len"] = 1.0;
}

/// \dfgPresetTitle TwoBoneDoubleMidJointIKSolver_Constructor_Init
/// \dfgPresetColor Color(49, 60, 61)
/// \dfgPresetHeaderColor Color(42, 94, 102)
/// \dfgPresetTextColor Color(168, 229, 240)
/// \dfgPresetFolder Solvers\TwoBoneDoubleMidJointIKSolver
function TwoBoneDoubleMidJointIKSolver(
  Xfo initPose[])
{
  TwoBoneDoubleMidJointIKSolver();
  this.initPose = initPose;
}


// Return Arguments for Kraken
/// \dfgPresetOmit
function KrakenSolverArg[] TwoBoneDoubleMidJointIKSolver.getArguments(){
  KrakenSolverArg args[] = this.parent.getArguments();
  args.push(KrakenSolverArg('rightSide', 'In', 'Boolean'));

  args.push(KrakenSolverArg('ikblend', 'In', 'Scalar'));

  args.push(KrakenSolverArg('root', 'In', 'Mat44'));
  args.push(KrakenSolverArg('bone0FK', 'In', 'Mat44'));
  args.push(KrakenSolverArg('bone1FK', 'In', 'Mat44'));
  args.push(KrakenSolverArg('bone2FK', 'In', 'Mat44'));
  args.push(KrakenSolverArg('ikHandle', 'In', 'Mat44'));
  args.push(KrakenSolverArg('upV', 'In', 'Mat44'));

  args.push(KrakenSolverArg('bone0Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('bone1Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('midJoint0Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('midJoint1Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('midJoint2Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('midJointRate', 'In', 'Scalar'));
  args.push(KrakenSolverArg('bone0Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('bone1Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('bone2Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('midJoint0Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('midJoint1Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('midJointOut', 'Out', 'Mat44'));
  return args;
}


// Solve
/// \dfgPresetTitle TwoBoneDoubleMidJointIKSolver_Solve
/// \dfgPresetColor Color(49, 60, 61)
/// \dfgPresetHeaderColor Color(42, 94, 102)
/// \dfgPresetTextColor Color(168, 229, 240)
/// \dfgPresetFolder Solvers\TwoBoneDoubleMidJointIKSolver
/// \dfgPresetRange rigScale (0.1, 1000.0)
/// \dfgPresetRange ikblend (0.0, 1.0)
function TwoBoneDoubleMidJointIKSolver.solve!
(
  Boolean drawDebug,
  Scalar rigScale,
  Boolean rightSide,

  Scalar ikblend,

  Mat44 root,
  Mat44 bone0FK,
  Mat44 bone1FK,
  Mat44 bone2FK,
  Mat44 ikHandle,
  Mat44 upV,

  Scalar bone0Len,
  Scalar bone1Len,
  Scalar midJoint0Len,
  Scalar midJoint1Len,
  Scalar midJoint2Len,
  Scalar midJointRate,

  io Mat44 bone0Out,
  io Mat44 bone1Out,
  io Mat44 bone2Out,
  io Mat44 midJoint0Out,
  io Mat44 midJoint1Out,
  io Mat44 midJointOut
) {

  Xfo bone0FkXfo = Xfo(bone0FK);
  Xfo bone1FkXfo = Xfo(bone1FK);
  Xfo bone2FkXfo = Xfo(bone2FK);
  Xfo bone0Xfo = bone0FkXfo;
  Xfo bone1Xfo = bone1FkXfo;
  Xfo bone2Xfo = bone2FkXfo;
  Xfo bone3Xfo = bone2Xfo;
  bone3Xfo.tr = bone2Xfo.transformVector(Vec3(bone1Len, 0.0, 0.0));
  Xfo midJointXfo = bone3Xfo;

  if (this.midJoint0TransformXfo == Xfo() ){
    this.midJoint0TransformXfo = Xfo();
    this.midJoint0TransformXfo.tr = Vec3(midJoint0Len, 0.0, 0.0); 
  }

  if (this.midJoint2TransformXfo == Xfo() ){
    this.midJoint2TransformXfo = Xfo();
    this.midJoint2TransformXfo.tr = Vec3( (midJoint2Len * -1.0), 0.0, 0.0); 
  }

  
  if(this.initPose.size() == 0) {
    midJointXfo = (bone3Xfo * this.midJoint2TransformXfo).toMat44();
    this.initPose.resize(4);
    this.initPose[0] = bone0FkXfo;
    this.initPose[1] = bone1FkXfo;
    this.initPose[2] = midJointXfo;
    this.initPose[3] = bone3Xfo;
  }

  Scalar scaledBone0Len = bone0Len * rigScale;
  Scalar scaledBone1Len = bone1Len * rigScale;
  Xfo ikPose[];
  ikPose.resize( 4 );

  if(ikblend > 0.0) {
    solve2BoneIK(
      scaledBone0Len,
      scaledBone1Len,
      root.translation(),
      upV.translation(),
      ikHandle.translation(),
      bone0Xfo,
      bone2Xfo
    );
    bone0Xfo.ori = bone0FkXfo.ori.sphericalLinearInterpolate(bone0Xfo.ori, ikblend);
    bone2Xfo.tr = bone0Xfo.transformVector(Vec3(bone0Len, 0.0, 0.0));
    bone2Xfo.ori = bone1FkXfo.ori.sphericalLinearInterpolate(bone2Xfo.ori, ikblend);

    // ------------------------------------------
    UInt32 ikIndex = 0;
    Xfo initPose[];
    initPose.resize(4);
    // Calculate the initpose offset by the chain base input
    for (Integer i=0; i < 4; i++) {
      initPose[i] = root * (this.initPose[0].inverse() * this.initPose[i]);
    }

    ikPose = solveNBoneIKWithUpVector(
      initPose, ikHandle.translation(), upV.translation(), Vec3(0, 1, 0), rigScale);

    // Now blend the IK result with the FK result
    /*
    for(UInt32 i=ikIndex; i < xfoPose.size(); i++) {

      xfoPose[i].ori = xfoPose[i].ori.sphericalLinearInterpolate(ikPose[i- ikIndex].ori, ikblend);

      if( i > 0 ){
        xfoPose[i].tr = xfoPose[i-1].transformVector(boneVectors[i-1]);
      }
    }
    */

  }

  // project bone2 to the end of bone 1
  bone3Xfo = bone2Xfo;
  bone3Xfo.tr = bone2Xfo.transformVector(Vec3(bone1Len, 0.0, 0.0));

  // Set Mid Joint Xfo
  midJointXfo.tr = bone2Xfo.tr;
  midJointXfo.ori = bone0Xfo.ori.sphericalLinearInterpolate(bone2Xfo.ori, 0.5);

  // Set scaling
  Vec3 outScaling = Vec3(rigScale, rigScale, rigScale);
  bone0Xfo.sc = outScaling;
  bone1Xfo.sc = outScaling;
  bone2Xfo.sc = outScaling;
  bone3Xfo.sc = outScaling;
  midJointXfo.sc = outScaling;

  bone0Out = bone0Xfo.toMat44();
  bone1Out = bone2Xfo.toMat44();
  bone2Out = bone3Xfo.toMat44();

  midJointOut = midJointXfo.toMat44();
  midJoint0Out = (bone0Xfo * this.midJoint0TransformXfo).toMat44();
  midJoint1Out = (bone3Xfo * this.midJoint2TransformXfo).toMat44();

  Scalar sub = (midJoint1Out.translation() - midJoint0Out.translation()).length();
  Scalar sub2 = sub - midJoint1Len;
  // report( sub2 * midJointRate );
  // report( sub2 * (1.0 - midJointRate) );

  bone0Out = ikPose[0].toMat44();
  bone1Out = ikPose[1].toMat44();
  bone2Out = ikPose[2].toMat44();

  midJoint0Out = ikPose[1].toMat44();
  midJoint1Out = ikPose[2].toMat44();

  // Set debugging visibility.
  this.setDebug(drawDebug);
  if(this.drawDebug){
    if(!this.handle)
      this.handle = DrawingHandle();
    Color boneColor(1.0, 1.0, 0);
    etDrawBone(this.handle.rootTransform, 'bone0', bone0Xfo, scaledBone0Len, scaledBone0Len * 0.05, boneColor);
    etDrawBone(this.handle.rootTransform, 'bone1', bone1Xfo, scaledBone1Len, scaledBone1Len * 0.05, boneColor);
    etDrawBone(this.handle.rootTransform, 'midJoint', bone1Xfo, midJoint1Len, midJoint1Len * 0.05, boneColor);

    Color lineColor = Color(0.7, 0.0, 0.0);
    drawCircle(this.handle.rootTransform, 'initPose0', this.initPose[0], 0.3, lineColor);
    drawCircle(this.handle.rootTransform, 'initPose1', this.initPose[1], 0.3, lineColor);
    drawCircle(this.handle.rootTransform, 'initPose2', this.initPose[2], 0.3, lineColor);
    drawCircle(this.handle.rootTransform, 'initPose3', this.initPose[3], 0.3, lineColor);

    lineColor = Color(0.0, 0.0, 0.7);
    drawCircle(this.handle.rootTransform, 'ikPose0', ikPose[0], 0.3, lineColor);
    drawCircle(this.handle.rootTransform, 'ikPose1', ikPose[1], 0.3, lineColor);
    drawCircle(this.handle.rootTransform, 'ikPose2', ikPose[2], 0.3, lineColor);
    drawCircle(this.handle.rootTransform, 'ikPose3', ikPose[3], 0.3, lineColor);
  }
}

// =========== TwoBoneDoubleMidJointIK Guide Solver ================ //
object TwoBoneDoubleMidJointIKGuideSolver : TwoBoneIKGuideSolver  {
  Xfo initPose[];
};

// Default Constructor
/// \dfgPresetTitle TwoBoneDoubleMidJointIKGuideSolver_Constructor
/// \dfgPresetColor Color(49, 60, 61)
/// \dfgPresetHeaderColor Color(42, 94, 102)
/// \dfgPresetTextColor Color(168, 229, 240)
/// \dfgPresetFolder Solvers\TwoBoneDoubleMidJointIKSolver\Guide
function TwoBoneDoubleMidJointIKGuideSolver()
{

}


// Return Arguments for Kraken
/// \dfgPresetOmit
function KrakenSolverArg[] TwoBoneDoubleMidJointIKGuideSolver.getArguments(){
  KrakenSolverArg args[] = this.parent.parent.getArguments();

  args.push(KrakenSolverArg('root', 'In', 'Mat44'));
  args.push(KrakenSolverArg('mid1', 'In', 'Mat44'));
  args.push(KrakenSolverArg('mid2', 'In', 'Mat44'));
  args.push(KrakenSolverArg('end', 'In', 'Mat44'));

  args.push(KrakenSolverArg('guideOpHost', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('mid', 'Out', 'Mat44'));
  return args;
}

/// \dfgPresetTitle TwoBoneDoubleMidJointIKGuideSolver_Solve
/// \dfgPresetColor Color(49, 60, 61)
/// \dfgPresetHeaderColor Color(42, 94, 102)
/// \dfgPresetTextColor Color(168, 229, 240)
/// \dfgPresetFolder Solvers\TwoBoneDoubleMidJointIKSolver\Guide
function TwoBoneDoubleMidJointIKGuideSolver.solve!(
  Boolean drawDebug,
  Scalar rigScale,

  Mat44 root,
  Mat44 mid1,
  Mat44 mid2,
  Mat44 end,
  io Mat44 guideOpHost,
  io Mat44 mid
) {

  Vec3 debugPositions1[];
  Vec3 debugPositions2[];
  debugPositions1.resize(4);
  debugPositions2.resize(3);

  Vec3 p1Start;
  Vec3 p1End;
  Vec3 p2Start;
  Vec3 p2End;

  p1Start = (root.inverse() * root).translation();
  p2Start = (root.inverse() * end).translation();
  p1End   = (root.inverse() * mid1).translation();
  p2End   = (root.inverse() * mid2).translation();

  Vec3 midPosition = calculateIntersectionFrom4Points(p1Start, p2Start, p1End, p2End);

  midPosition = root * midPosition;
  mid = Mat44();
  mid.setTranslation( midPosition );

  debugPositions1[0] = root.translation();
  debugPositions1[1] = mid1.translation();
  debugPositions1[2] = mid2.translation();
  debugPositions1[3] = end.translation();

  debugPositions2[0] = root.translation();
  debugPositions2[1] = midPosition;
  debugPositions2[2] = end.translation();

  guideOpHost = Mat44();

  // Set debugging visibility.
  this.setDebug(drawDebug);

  if(this.drawDebug){

    if(!this.handle){
      this.handle = DrawingHandle();
    }

    Color lineColor(1.0, 1.0, 0);
    drawLineStrip(this.handle.rootTransform, 'TwoBoneDoubleMidJointIKGuideLines1', debugPositions1, lineColor);
    lineColor = Color(1.0, 0.0, 0);
    drawLineStrip(this.handle.rootTransform, 'TwoBoneDoubleMidJointIKGuideLines2', debugPositions2, lineColor);
    drawCircle(this.handle.rootTransform, 'TwoBoneDoubleMidJointIKGuideCircle', Xfo(midPosition), 1.0, lineColor);
    
    lineColor = Color(0.1, 0.1, 0.1);
    drawCircle(this.handle.rootTransform, 'TwoBoneDoubleMidJointIKGuideCircle1', Xfo(p1Start), 0.3, lineColor);
    lineColor = Color(0.2, 0.2, 0.0);
    drawCircle(this.handle.rootTransform, 'TwoBoneDoubleMidJointIKGuideCircle2', Xfo(p2Start), 0.3, lineColor);
    lineColor = Color(0.4, 0.4, 0.0);
    drawCircle(this.handle.rootTransform, 'TwoBoneDoubleMidJointIKGuideCircle3', Xfo(p1End), 0.3, lineColor);
    lineColor = Color(0.7, 0.0, 0.0);
    drawCircle(this.handle.rootTransform, 'TwoBoneDoubleMidJointIKGuideCircle4', Xfo(p2End), 0.3, lineColor);
  }
}


inline function Vec3 calculateIntersectionFrom4Points(Vec3 p1, Vec3 p2, Vec3 p3, Vec3 p4){

  Scalar x, y, y1, y2, z, s1, s2;
  Vec3 mid = (p1 + p2) / 2.0f;
  Vec3 mid1 = p3 - mid;
  Vec3 mid2 = p4 - mid;
  report( "<<<<" );
  report( p1 );
  report( p2 );
  report( p3 );
  report( p4 );

  report( "mid" );
  report( mid  );
  report( mid1 );
  report( mid2 );

  Boolean isXInvalid = false;
  Boolean isY1Invalid = false;
  Boolean isY2Invalid = false;
  Boolean isZInvalid = false;

  // detect normal dir is in same
  if (( mid1.x >= 0 ) && ( mid2.x >= 0 )){
    // report( "x goood" );
  } else if (( mid1.x < 0 ) && ( mid2.x < 0 )){
    // report( "x goood" );
  } else {
    isXInvalid = true;
  }

  if (( mid1.z >= 0 ) && ( mid2.z >= 0 )){
    // report( "z goood" );
  } else if (( mid1.z < 0 ) && ( mid2.z < 0 )){
    // report( "z goood" );
  } else {
    isZInvalid = true;
  }

  // x-y plane cross
  s1 = ((p4.x - p2.x) * (p1.y - p2.y) - (p4.y - p2.y) * (p1.x - p2.x)) * 0.5;
  s2 = ((p4.x - p2.x) * (p2.y - p3.y) - (p4.y - p2.y) * (p2.x - p3.x)) * 0.5;
  x  = p1.x + (p3.x - p1.x) * (s1 / (s1 + s2));
  y1 = p1.y + (p3.y - p1.y) * (s1 / (s1 + s2));

  if (x.isNaN() || isXInvalid){
    // x = (p1.x + p2.x + p3.x + p4.x) / 4.0f;
    x = (p3.x + p4.x) / 2.0f;
  }
  if (y1.isNaN() || isXInvalid){
    // y1 = (p1.y + p2.y + p3.y + p4.y) / 4.0f;
    y1 = (p3.y + p4.y) / 2.0f;
  }

  // z-y plane cross
  s1 = ((p4.z - p2.z) * (p1.y - p2.y) - (p4.y - p2.y) * (p1.z - p2.z)) * 0.5;
  s2 = ((p4.z - p2.z) * (p2.y - p3.y) - (p4.y - p2.y) * (p2.z - p3.z)) * 0.5;
  z  = p1.z + (p3.z - p1.z) * (s1 / (s1 + s2));
  y2 = p1.y + (p3.y - p1.y) * (s1 / (s1 + s2));

  if (y2.isNaN() || isZInvalid){
    y2 = (p3.z + p4.z) / 2.0f;
  }
  if (z.isNaN() || isZInvalid){
    // z = (p1.z + p2.z + p3.z + p4.z) / 4.0f;
    z = (p3.z + p4.z) / 2.0f;
  }

  if (y1 < p2.y || p1.y < y1){
    isY1Invalid = true;
  }
  if (y2 < p2.y || p1.y < y2){
    isY2Invalid = true;
  }

  if (isY1Invalid && isY2Invalid) {
    report( "case 1" );
    y = (p3.y + p4.y) / 2.0f;
  } else if( isY1Invalid ){
    report( "case 2" );
    y = y2;
  } else if( isY2Invalid ){
    report( "case 3" );
    y = y1;
  } else if( y2 == 0.0f ){
    y = y1;
  } else if( y1 == 0.0f ){
    y = y2;
  } else {
    y = (y1 + y2) / 2.0f;
    y = y2;
  }

  report( "y" );
  report( y );
  report( y1);
  report( y2);



  return Vec3(x, y, z);
}
