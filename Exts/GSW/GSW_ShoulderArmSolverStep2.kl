require Math;
require InlineDrawing;
require Kraken;


object GswShoulderArmSolverStep2 : KrakenSolver {
  Xfo initPose[];
};

// Default Constructor
function GswShoulderArmSolverStep2()
{

}

function GswShoulderArmSolverStep2(
  Xfo initPose[])
{
  this.initPose = initPose;
}


// Return Arguments for Kraken
function KrakenSolverArg[] GswShoulderArmSolverStep2.getArguments(){

  KrakenSolverArg args[] = this.parent.getArguments();

  args.push(KrakenSolverArg('rightSide', 'In', 'Boolean'));
  args.push(KrakenSolverArg('bone0Len', 'In', 'Scalar'));

  args.push(KrakenSolverArg('modifier', 'In', 'Scalar'));
  args.push(KrakenSolverArg('upRate', 'In', 'Scalar'));
  args.push(KrakenSolverArg('downRate', 'In', 'Scalar'));
  args.push(KrakenSolverArg('forwardRate', 'In', 'Scalar'));
  args.push(KrakenSolverArg('backwardRate', 'In', 'Scalar'));

  args.push(KrakenSolverArg('clavicleRoot', 'In', 'Mat44'));
  args.push(KrakenSolverArg('elbowRefPosition', 'In', 'Mat44'));
  args.push(KrakenSolverArg('elbow1stPosition', 'In', 'Mat44'));

  args.push(KrakenSolverArg('clavicleOut', 'Out', 'Mat44'));
  return args;
}


// Solve
function GswShoulderArmSolverStep2.solve!
(
  in Boolean drawDebug,
  in Scalar rigScale,
  in Boolean rightSide,
  in Scalar bone0Len,

  in Scalar modifier,
  in Scalar upRate,
  in Scalar downRate,
  in Scalar forwardRate,
  in Scalar backwardRate,

  in Mat44 clavicleRoot,
  in Mat44 elbowRefPosition,
  in Mat44 elbow1stPosition,

  out Mat44 clavicleOut 
) {

  Xfo rootXfo = Xfo(clavicleRoot);
  Xfo outXfo = Xfo();
  outXfo.tr = rootXfo.tr;

  // return first if nothing to need
  if (modifier == 0) {

    outXfo.ori = rootXfo.ori;
    clavicleOut = outXfo.toMat44();
    return;

  }

  if (rightSide) {
    Quat inverseRotX();
    inverseRotX.setFromEulerAngles( 0, 0, Math_degToRad(180) );
    // rootXfo.ori = rootXfo.ori * inverseRotX;
    rootXfo.ori = inverseRotX * rootXfo.ori;
  }

  Xfo elbowRefXfo = Xfo(elbowRefPosition);
  Xfo elbow1stXfo = Xfo(elbow1stPosition);

  Vec3 tmp = ( elbow1stXfo.tr - elbowRefXfo.tr ) / bone0Len;
  tmp = rootXfo.ori.rotateVector( tmp );

  // normalize
  // x: range( -1.0 to 1.0 ) default 1.0
  // y: range( -1.0 to 1.0 ) default 0.0
  // z: range( -1.0 to 1.0 ) default 0.0
  tmp.x = tmp.x.clamp( -1.0f, 1.0f );
  tmp.y = tmp.y.clamp( -1.0f, 1.0f );
  tmp.z = tmp.z.clamp( -1.0f, 1.0f );
  Vec3 tmp2 = Vec3(tmp);

  if ( rightSide ){
    tmp.x = acos( tmp.x ) - ( PI / 2 );
    tmp.y = asin( tmp.y );
    tmp.z = asin( tmp.z ) * -1;

  } else {
    tmp.x = acos( tmp.x ) - ( PI / 2 );
    tmp.y = asin( tmp.y );
    tmp.z = asin( tmp.z ) * -1;

  }

  if (0 < tmp.x) {
    /*
       if (tmp2.y < 0) {
       tmp.y -= asin(tmp2.x) * -2;

       } else { // up
       tmp.y += asin(tmp2.x) * -2;
       }
     */

    if (tmp2.z < 0){  // back
      tmp.z += asin(tmp2.x) * -2;
    } else {
      tmp.z -= asin(tmp2.x) * -2;
    }
  }

  /*
  // clamp
  if ( tmp.x.isNaN() ){
    if ( tmp2.x > 0 ){
      tmp.x = 0.0f;
    } else {
      tmp.x = PI / 2;
    }
  }

  if ( tmp.y.isNaN() && tmp2.y > 0 ){
    if (tmp2.y > 0 ){
      tmp.y = PI / 2;
    } else {
      tmp.y = PI / -2;
    }
  }

  if ( tmp.z.isNaN() && tmp2.z > 0 ){
    if ( tmp2.z > 0 ){
      tmp.z = PI / -2;
    } else {
      tmp.z = PI / 2;
    }
  }
  */

  // apply rate
  Vec3 outRotVec();

  tmp *= modifier;
  if (0 < tmp.y) {
    outRotVec.x = upRate * tmp.y;

  } else {
    outRotVec.x = downRate * tmp.y;

  }

  if (tmp.z < 0) {
    outRotVec.z = forwardRate  * tmp.z;

  } else {                             
    outRotVec.z = backwardRate * tmp.z;

  }

  outXfo.tr = rootXfo.tr;

  Quat corretionQuat();
  corretionQuat.setFromEulerAngles( 0, outRotVec.z, outRotVec.x, RotationOrder('yzx') );
  corretionQuat = rootXfo.inverse().ori * corretionQuat;
  outXfo.ori = corretionQuat;
  clavicleOut = outXfo.toMat44();
}
